# CLI 归档命令规范

## 目的
归档命令将已完成的变化从活动更改目录移动到归档文件夹，使用基于日期的命名方式，遵循 OpenSpec 规范。

## 命令语法
```bash
openspec archive [change-name] [--yes|-y]
```

选项：
- `--yes`, `-y`: 跳过确认提示（用于自动化）

## 要求
### 要求：变更选择

命令应支持交互式和直接变更选择方法。

#### 场景：交互式选择

- **当** 未提供 change-name 时
- **则** 显示可用变更的交互式列表（排除 archive/）
- **并** 允许用户选择一个

#### 场景：直接选择

- **当** 提供了 change-name 时
- **则** 直接使用该变更
- **并** 验证其存在性

### 要求：任务完成检查

命令应在归档前验证任务完成状态，以防止过早归档。

#### 场景：发现未完成任务

- **当** 发现未完成任务（标记为 `- [ ]`）
- **则** 向用户显示所有未完成任务
- **并** 提示确认是否继续
- **并** 默认为"否"以确保安全

#### 场景：所有任务已完成

- **当** 所有任务已完成或不存在 tasks.md 时
- **则** 无需提示直接进行归档

### 要求：归档流程

归档操作应遵循结构化流程，安全地将变更移动到归档位置。

#### 场景：执行归档

- **当** 归档一个变更时
- **则** 执行以下步骤：
  1. 如果不存在则创建 archive/ 目录
  2. 使用当前日期生成目标名称为 `YYYY-MM-DD-[change-name]`
  3. 检查目标目录是否已存在
  4. 从变更的未来状态规范更新主规范（见下面的规范更新流程）
  5. 将整个变更目录移动到归档位置

#### 场景：归档已存在

- **当** 目标归档已存在时
- **则** 失败并显示错误消息
- **并** 不覆盖现有归档

#### 场景：成功归档

- **当** 移动成功时
- **则** 显示成功消息，包含归档名称和更新的规范列表

### 要求：规范更新流程

在将变更移动到归档之前，命令应将增量更改应用到主规范，以反映已部署的现实状态。

#### 场景：应用增量更改

- **当** 归档具有基于增量的规范的变更时
- **则** 解析并应用 openspec-conventions 中定义的增量更改
- **并** 在应用前验证所有操作

#### 场景：验证增量更改

- **当** 处理增量更改时
- **则** 执行 openspec-conventions 中指定的验证
- **并** 如果验证失败，显示具体错误并中止

#### 场景：冲突检测

- **当** 应用增量会导致重复的需求标题时
- **则** 中止并显示冲突错误消息
- **并** 建议手动解决

### 要求：确认行为

规范更新确认应在应用更改前提供清晰的变更可见性。

#### 场景：显示确认信息

- **当** 提示确认时
- **则** 显示清晰的摘要，展示：
  - 将创建哪些规范（新功能）
  - 将更新哪些规范（现有功能）
  - 每个规范的源路径
- **并** 将确认提示格式化为：
  ```
  以下规范将被更新：
  
  要创建的新规范：
    - cli-archive（来自 changes/add-archive-command/specs/cli-archive/spec.md）
  
  要更新的现有规范：
    - cli-init（来自 changes/update-init-command/specs/cli-init/spec.md）
  
  更新2个规范并归档 'add-archive-command'？[y/N]：
  ```

#### 场景：处理确认响应

- **当** 等待用户确认时
- **则** 默认为"否"以确保安全（需要明确的"y"或"yes"）
- **并** 当提供 `--yes` 或 `-y` 标志时跳过确认

#### 场景：用户拒绝确认

- **当** 用户拒绝确认时
- **则** 中止整个归档操作
- **并** 显示消息："归档已取消。未进行任何更改。"
- **并** 以非零状态码退出

### 要求：错误条件

命令应优雅处理各种错误条件。

#### 场景：处理错误

- **当** 发生错误时
- **则** 处理以下条件：
  - 缺少 openspec/changes/ 目录
  - 未找到变更
  - 归档目标已存在
  - 文件系统权限问题

### 要求：跳过规范选项

归档命令应支持 `--skip-specs` 标志，跳过所有规范更新操作，直接进行归档。

#### 场景：使用标志跳过规范更新

- **当** 执行 `openspec archive <change> --skip-specs` 时
- **则** 跳过规范发现和更新确认
- **并** 直接进行变更归档
- **并** 显示跳过规范的消息

### 要求：非阻塞确认

当用户拒绝规范更新时，归档操作应继续进行，而不是取消整个操作。

#### 场景：用户拒绝规范更新确认

- **当** 用户拒绝规范更新确认时
- **则** 跳过规范更新
- **并** 继续归档操作
- **并** 显示成功消息，指示规范未更新

### 要求：显示输出

命令应提供关于增量操作的清晰反馈。

#### 场景：显示增量应用

- **当** 应用增量更改时
- **则** 显示每个规范：
  - 添加的需求数量
  - 修改的需求数量
  - 删除的需求数量
  - 重命名的需求数量
- **并** 使用 openspec-conventions 中定义的标准输出符号（+ ~ - →）：
  ```
  正在将更改应用到 specs/user-auth/spec.md：
    + 2 已添加
    ~ 3 已修改
    - 1 已删除
    → 1 已重命名
  ```

### 要求：归档验证

归档命令应在应用更改前验证变更，以确保数据完整性。

#### 场景：归档前验证

- **当** 执行 `openspec archive change-name` 时
- **则** 首先验证变更结构
- **并** 仅当验证通过时继续
- **并** 如果验证失败则显示验证错误

#### 场景：无验证强制归档

- **当** 执行 `openspec archive change-name --no-validate` 时
- **则** 跳过验证（不安全模式）
- **并** 显示跳过验证的警告

## 为什么做出这些决策

**交互式选择**：减少打字量，帮助用户查看可用变更
**任务检查**：防止意外归档未完成的工作
**日期前缀**：保持时间顺序并防止命名冲突
**不覆盖**：保留历史归档并防止数据丢失
**归档前规范更新**：主目录中的规范代表当前现实；当变更部署并归档时，其未来状态规范成为新的现实，必须替换主规范
**规范更新确认**：提供将要更改的可见性，防止意外覆盖，并确保用户在修改规范前了解影响
**用于自动化的 --yes 标志**：允许 CI/CD 管道在不交互提示的情况下归档，同时为手动使用保持默认安全性