# OpenSpec 约定规范

## 目的

OpenSpec 约定应定义系统功能如何记录、变更如何提出和跟踪，以及规范如何随时间演变。此元规范作为 OpenSpec 自身约定的真相来源。

## 要求
### 要求：规范和变更的结构化约定

OpenSpec 约定应强制使用具有清晰需求和场景部分的结构化规范格式，以便工具可以一致地解析。

#### 场景：遵循结构化规范格式

- **当** 编写或更新 OpenSpec 规范时
- **则** 作者应使用 `### Requirement: ...` 后跟至少一个 `#### Scenario: ...` 部分

### 要求：项目结构

OpenSpec 项目应为规范和变更维护一致的目录结构。

#### 场景：初始化项目结构

- **当** OpenSpec 项目被初始化时
- **则** 应具有以下结构：
```
openspec/
├── project.md              # 项目特定上下文
├── AGENTS.md               # AI 助手指令
├── specs/                  # 当前部署的功能
│   └── [capability]/       # 单一、专注的功能
│       ├── spec.md         # 什么和为什么
│       └── design.md       # 如何（可选，用于已建立的模式）
└── changes/                # 提议的变更
    ├── [change-name]/      # 描述性变更标识符
    │   ├── proposal.md     # 为什么、什么和影响
    │   ├── tasks.md        # 实施清单
    │   ├── design.md       # 技术决策（可选）
    │   └── specs/          # 完整未来状态
    │       └── [capability]/
    │           └── spec.md # 干净的 Markdown（无差异语法）
    └── archive/            # 已完成变更
        └── YYYY-MM-DD-[name]/
```

### 要求：行为规范的结构化格式

行为规范应使用具有一致部分标题和关键字的结构化格式，以确保视觉一致性和可解析性。

#### 场景：编写需求部分

- **当** 在行为规范中记录需求时
- **则** 使用带有格式 `### Requirement: [Name]` 的 3 级标题
- **并** 立即后跟描述核心行为的 SHALL 语句
- **并** 保持需求名称描述性且少于 50 个字符

#### 场景：记录场景

- **当** 记录特定行为或用例时
- **则** 使用带有格式 `#### Scenario: [Description]` 的 4 级标题
- **并** 使用带有粗体关键字的项目符号表示步骤：
  - **GIVEN** 用于初始状态（可选）
  - **WHEN** 用于条件或触发器
  - **THEN** 用于预期结果
  - **AND** 用于额外结果或条件

#### 场景：添加实施细节

- **当** 步骤需要额外细节时
- **则** 在主要步骤下使用子项目符号
- **并** 保持一致的缩进
  - 子项目符号提供示例或具体内容
  - 保持子项目符号简洁

### 要求：基于标题的需求识别

需求标题应作为在现有规范和提议变更之间进行程序化匹配的唯一标识符。

#### 场景：程序化匹配需求

- **当** 处理增量变更时
- **则** 使用 `### Requirement: [Name]` 标题作为唯一标识符
- **并** 使用规范化标题进行匹配：`normalize(header) = trim(header)`
- **并** 在规范化后使用区分大小写的相等性比较标题

#### 场景：处理需求重命名

- **当** 重命名需求时
- **则** 使用特殊的 `## RENAMED Requirements` 部分
- **并** 明确指定旧名称和新名称：
  ```markdown
  ## RENAMED Requirements
  - FROM: `### Requirement: Old Name`
  - TO: `### Requirement: New Name`
  ```
- **并** 如果内容也更改，请使用新标题包含在 MODIFIED 下

#### 场景：验证标题唯一性

- **当** 创建或修改需求时
- **则** 确保规范中不存在重复标题
- **并** 验证工具应将重复标题标记为错误

### 要求：变更存储约定

变更提案应仅存储对规范的添加、修改和删除，而不是完整的未来状态。

#### 场景：创建带有添加的变更提案

- **当** 创建添加新需求的变更提案时
- **则** 仅在 `## ADDED Requirements` 下包含新需求
- **并** 每个需求应包括其完整内容
- **并** 使用标准的结构化格式用于需求和场景

#### 场景：创建带有修改的变更提案

- **当** 创建修改现有需求的变更提案时
- **则** 在 `## MODIFIED Requirements` 下包含修改的需求
- **并** 使用与当前规范中相同的标题文本（规范化）
- **并** 包括完整的修改需求（不是差异）
- **并** 可选地使用内联注释（如 `← (was X)`）注释更改内容

#### 场景：创建带有删除的变更提案

- **当** 创建删除需求的变更提案时
- **则** 在 `## REMOVED Requirements` 下列出它们
- **并** 使用规范化标题文本进行识别
- **并** 包括删除原因
- **并** 如果适用，记录任何迁移路径

`changes/[name]/specs/` 目录应包含：
- 仅显示更改内容的增量文件
- 用于 ADDED、MODIFIED、REMOVED 和 RENAMED 需求的部分
- 用于需求识别的规范化标题匹配
- 使用结构化格式的完整需求
- 每个需求的更改类型的清晰指示

#### 场景：使用标准输出符号

- **当** 在 CLI 输出中显示增量操作时
- **则** 使用这些标准符号：
  - `+` 表示 ADDED（绿色）
  - `~` 表示 MODIFIED（黄色）
  - `-` 表示 REMOVED（红色）
  - `→` 表示 RENAMED（青色）

### 要求：归档流程增强

归档过程应使用基于标题的匹配程序化地将增量更改应用到当前规范。

#### 场景：归档带有增量的变更

- **当** 归档已完成变更时
- **则** 归档命令应：
  1. 首先解析 RENAMED 部分并应用重命名
  2. 解析 REMOVED 部分并通过规范化标题匹配删除
  3. 解析 MODIFIED 部分并通过规范化标题匹配替换（如果重命名则使用新名称）
  4. 解析 ADDED 部分并附加新需求
- **并** 验证所有 MODIFIED/REMOVED 标题在当前规范中存在
- **并** 验证 ADDED 标题尚不存在
- **并** 在主 specs/ 目录中生成更新的规范

#### 场景：归档期间处理冲突

- **当** 增量更改与当前规范状态冲突时
- **则** 归档命令应报告特定冲突
- **并** 需要手动解决才能继续
- **并** 提供解决冲突的清晰指导

### 要求：提案格式

提案应通过清晰的从/到比较明确记录所有更改。

#### 场景：记录更改

- **当** 记录更改内容时
- **则** 提案应明确描述每个更改：

```markdown
**[部分或行为名称]**
- From: [当前状态/需求]
- To: [未来状态/需求]
- Reason: [为什么需要此更改]
- Impact: [破坏性/非破坏性，影响谁]
```

这种明确格式弥补了没有内联差异的不足，并确保审查者确切理解将更改什么。

### 要求：变更审查

系统应支持多种方法来审查提议的变更。

#### 场景：审查变更

- **当** 审查提议的变更时
- **则** 审查者可以使用以下方式进行比较：
- 提交变更时的 GitHub PR 差异视图
- 命令行：`diff -u specs/[capability]/spec.md changes/[name]/specs/[capability]/spec.md`
- 任何比较当前与未来状态的视觉差异工具

### 要求：采用结构化格式

行为规范应采用带有 `### Requirement:` 和 `#### Scenario:` 标题的结构化格式作为默认设置。

#### 场景：使用结构化标题表示行为

- **当** 记录行为需求时
- **则** 使用 `### Requirement:` 表示需求
- **并** 使用带有粗体 WHEN/THEN/AND 关键字的 `#### Scenario:` 表示场景

### 要求：动词-名词 CLI 命令结构

OpenSpec CLI 设计应使用动词作为顶级命令，名词作为参数或标志用于范围界定。

#### 场景：动词优先的命令发现

- **当** 用户运行像 `openspec list` 这样的命令时
- **则** 动词清楚地传达动作
- **并** 名词通过标志或参数（例如 `--changes`、`--specs`）细化范围

#### 场景：名词命令的向后兼容性

- **当** 用户运行名词前缀命令，如 `openspec spec ...` 或 `openspec change ...` 时
- **则** CLI 应继续支持它们至少一个版本
- **并** 显示指向动词优先替代方案的弃用警告

#### 场景：消除歧义指导

- **当** 项目名称在变更和规范之间模糊时
- **则** `openspec show` 和 `openspec validate` 应接受 `--type spec|change`
- **并** 帮助文本应清楚地记录这一点

## 核心原则

系统应遵循这些原则：
- 规范反映当前构建和部署的内容
- 变更包含应更改内容的提案
- AI 驱动文档过程
- 规范是与部署代码保持同步的活文档

## 目录结构

### 要求：项目结构

OpenSpec 项目应为规范和变更维护一致的目录结构。

#### 场景：初始化项目结构

- **当** OpenSpec 项目被初始化时
- **则** 应具有以下结构：
```
openspec/
├── project.md              # 项目特定上下文
├── AGENTS.md               # AI 助手指令
├── specs/                  # 当前部署的功能
│   └── [capability]/       # 单一、专注的功能
│       ├── spec.md         # 什么和为什么
│       └── design.md       # 如何（可选，用于已建立的模式）
└── changes/                # 提议的变更
    ├── [change-name]/      # 描述性变更标识符
    │   ├── proposal.md     # 为什么、什么和影响
    │   ├── tasks.md        # 实施清单
    │   ├── design.md       # 技术决策（可选）
    │   └── specs/          # 完整未来状态
    │       └── [capability]/
    │           └── spec.md # 干净的 Markdown（无差异语法）
    └── archive/            # 已完成变更
        └── YYYY-MM-DD-[name]/
```

## 规范格式

### 要求：行为规范的结构化格式

行为规范应使用具有一致部分标题和关键字的结构化格式，以确保视觉一致性和可解析性。

#### 场景：编写需求部分

- **当** 在行为规范中记录需求时
- **则** 使用带有格式 `### Requirement: [Name]` 的 3 级标题
- **并** 立即后跟描述核心行为的 SHALL 语句
- **并** 保持需求名称描述性且少于 50 个字符

#### 场景：记录场景

- **当** 记录特定行为或用例时
- **则** 使用带有格式 `#### Scenario: [Description]` 的 4 级标题
- **并** 使用带有粗体关键字的项目符号表示步骤：
  - **GIVEN** 用于初始状态（可选）
  - **WHEN** 用于条件或触发器
  - **THEN** 用于预期结果
  - **AND** 用于额外结果或条件

#### 场景：添加实施细节

- **当** 步骤需要额外细节时
- **则** 在主要步骤下使用子项目符号
- **并** 保持一致的缩进
  - 子项目符号提供示例或具体内容
  - 保持子项目符号简洁

## 变更存储约定

### 要求：基于标题的需求识别

需求标题应作为在现有规范和提议变更之间进行程序化匹配的唯一标识符。

#### 场景：程序化匹配需求

- **当** 处理增量变更时
- **则** 使用 `### Requirement: [Name]` 标题作为唯一标识符
- **并** 使用规范化标题进行匹配：`normalize(header) = trim(header)`
- **并** 在规范化后使用区分大小写的相等性比较标题

#### 场景：处理需求重命名

- **当** 重命名需求时
- **则** 使用特殊的 `## RENAMED Requirements` 部分
- **并** 明确指定旧名称和新名称：
  ```markdown
  ## RENAMED Requirements
  - FROM: `### Requirement: Old Name`
  - TO: `### Requirement: New Name`
  ```
- **并** 如果内容也更改，请使用新标题包含在 MODIFIED 下

#### 场景：验证标题唯一性

- **当** 创建或修改需求时
- **则** 确保规范中不存在重复标题
- **并** 验证工具应将重复标题标记为错误

### 要求：变更存储约定

变更提案应仅存储对规范的添加、修改和删除，而不是完整的未来状态。

#### 场景：创建带有添加的变更提案

- **当** 创建添加新需求的变更提案时
- **则** 仅在 `## ADDED Requirements` 下包含新需求
- **并** 每个需求应包括其完整内容
- **并** 使用标准的结构化格式用于需求和场景

#### 场景：创建带有修改的变更提案

- **当** 创建修改现有需求的变更提案时
- **则** 在 `## MODIFIED Requirements` 下包含修改的需求
- **并** 使用与当前规范中相同的标题文本（规范化）
- **并** 包括完整的修改需求（不是差异）
- **并** 可选地使用内联注释（如 `← (was X)`）注释更改内容

#### 场景：创建带有删除的变更提案

- **当** 创建删除需求的变更提案时
- **则** 在 `## REMOVED Requirements` 下列出它们
- **并** 使用规范化标题文本进行识别
- **并** 包括删除原因
- **并** 如果适用，记录任何迁移路径

`changes/[name]/specs/` 目录应包含：
- 仅显示更改内容的增量文件
- 用于 ADDED、MODIFIED、REMOVED 和 RENAMED 需求的部分
- 用于需求识别的规范化标题匹配
- 使用结构化格式的完整需求
- 每个需求的更改类型的清晰指示

#### 场景：使用标准输出符号

- **当** 在 CLI 输出中显示增量操作时
- **则** 使用这些标准符号：
  - `+` 表示 ADDED（绿色）
  - `~` 表示 MODIFIED（黄色）
  - `-` 表示 REMOVED（红色）
  - `→` 表示 RENAMED（青色）

### 要求：归档流程增强

归档过程应使用基于标题的匹配程序化地将增量更改应用到当前规范。

#### 场景：归档带有增量的变更

- **当** 归档已完成变更时
- **则** 归档命令应：
  1. 首先解析 RENAMED 部分并应用重命名
  2. 解析 REMOVED 部分并通过规范化标题匹配删除
  3. 解析 MODIFIED 部分并通过规范化标题匹配替换（如果重命名则使用新名称）
  4. 解析 ADDED 部分并附加新需求
- **并** 验证所有 MODIFIED/REMOVED 标题在当前规范中存在
- **并** 验证 ADDED 标题尚不存在
- **并** 在主 specs/ 目录中生成更新的规范

#### 场景：归档期间处理冲突

- **当** 增量更改与当前规范状态冲突时
- **则** 归档命令应报告特定冲突
- **并** 需要手动解决才能继续
- **并** 提供解决冲突的清晰指导

### 要求：提案格式

提案应通过清晰的从/到比较明确记录所有更改。

#### 场景：记录更改

- **当** 记录更改内容时
- **则** 提案应明确描述每个更改：

```markdown
**[部分或行为名称]**
- From: [当前状态/需求]
- To: [未来状态/需求]
- Reason: [为什么需要此更改]
- Impact: [破坏性/非破坏性，影响谁]
```

这种明确格式弥补了没有内联差异的不足，并确保审查者确切理解将更改什么。

## 变更生命周期

变更过程应遵循这些状态：

1. **提议**：AI 创建具有未来状态规范和明确提案的变更
2. **审查**：人类审查提案和未来状态
3. **批准**：变更被批准实施
4. **实施**：遵循 tasks.md 清单（可以跨越多个 PR）
5. **部署**：变更部署到生产环境
6. **更新**：`specs/` 中的规范更新以匹配部署的现实
7. **归档**：变更移动到 `archive/YYYY-MM-DD-[name]/`

## 查看变更

### 要求：变更审查

系统应支持多种方法来审查提议的变更。

#### 场景：审查变更

- **当** 审查提议的变更时
- **则** 审查者可以使用以下方式进行比较：
- 提交变更时的 GitHub PR 差异视图
- 命令行：`diff -u specs/[capability]/spec.md changes/[name]/specs/[capability]/spec.md`
- 任何比较当前与未来状态的视觉差异工具

系统依赖工具生成差异，而不是存储它们。

## 功能命名

功能应使用：
- 动词-名词模式（例如 `user-auth`、`payment-capture`）
- 带连字符的小写名称
- 单一焦点（每个功能一个职责）
- 无嵌套（`specs/` 下的扁平结构）

## 何时需要提案

应为以下内容创建提案：
- 新功能或能力
- 对现有行为的破坏性更改
- 架构或模式更改
- 更改行为的性能优化
- 影响访问模式的安全更新

以下情况不需要提案：
- 恢复预期行为的错误修复
- 拼写错误或格式化修复
- 非破坏性依赖更新
- 为现有行为添加测试
- 文档澄清

## 为什么采用这种方法

干净的未来状态存储提供：
- **可读性**：无差异语法污染
- **AI 兼容性**：AI 工具理解的标准 Markdown
- **简单性**：无需特殊解析或处理
- **工具无关性**：任何差异工具都可以显示更改
- **清晰意图**：明确提案记录推理

结构化格式添加：
- **视觉一致性**：需求和场景前缀使部分立即可识别
- **可解析性**：一致的结构启用工具和自动化
- **渐进采用**：现有规范可以逐步迁移