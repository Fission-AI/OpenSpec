# OpenSpec 约定规范

## 目的

OpenSpec 约定应定义系统功能如何记录、变更如何提议和跟踪，以及规范如何随时间演变。这个元规范作为 OpenSpec 自身约定的权威来源。

## 核心原则

系统应遵循这些原则：
- 规范反映当前已构建和部署的内容
- 变更包含应变更内容的提议
- AI 驱动文档过程
- 规范是与部署代码保持同步的活文档

## 目录结构

当初始化 OpenSpec 项目时
则应具有此结构：
```
openspec/
├── project.md              # 项目特定上下文
├── README.md               # AI 助手指令
├── specs/                  # 当前部署的功能
│   └── [capability]/       # 单一、专注的功能
│       ├── spec.md         # WHAT 和 WHY
│       └── design.md       # HOW（可选，用于已建立的模式）
└── changes/                # 提议的变更
   ├── [change-name]/      # 描述性变更标识符
   │   ├── proposal.md     # 为什么、什么和影响
   │   ├── tasks.md        # 实现检查清单
   │   ├── design.md       # 技术决策（可选）
   │   └── specs/          # 完整的未来状态
   │       └── [capability]/
   │           └── spec.md # 干净的 markdown（无差异语法）
   └── archive/            # 已完成的变更
       └── YYYY-MM-DD-[name]/
```

## 变更存储约定

### 未来状态存储

当创建变更提议时
则存储受影响规范的完整未来状态
并使用干净的 markdown 而无差异语法

`changes/[name]/specs/` 目录应包含：
- 变更后的完整规范文件
- 干净的 markdown 无 `+` 或 `-` 前缀
- 所有最终预期状态的格式和结构

### 提议格式

当记录变更内容时
则提议应明确描述每个变更：

```markdown
**[部分或行为名称]**
- 从：[当前状态/要求]
- 到：[未来状态/要求]
- 原因：[为什么需要此变更]
- 影响：[破坏性/非破坏性，谁受影响]
```

这种明确格式弥补了没有内联差异的不足，并确保审查者准确理解将要变更的内容。

## 变更生命周期

变更过程应遵循这些状态：

1. **提议**：AI 创建包含未来状态规范和明确提议的变更
2. **审查**：人类审查提议和未来状态
3. **批准**：变更被批准实施
4. **实施**：遵循 tasks.md 检查清单（可跨越多个 PR）
5. **部署**：变更部署到生产环境
6. **更新**：`specs/` 中的规范更新以匹配部署的实际情况
7. **归档**：变更移动到 `archive/YYYY-MM-DD-[name]/`

## 查看变更

当审查提议的变更时
则审查者可以使用以下方式比较：
- GitHub PR 差异视图（当变更被提交时）
- 命令行：`diff -u specs/[capability]/spec.md changes/[name]/specs/[capability]/spec.md`
- 任何视觉差异工具比较当前与未来状态

系统依赖工具生成差异而不是存储它们。

## 功能命名

功能应使用：
- 动词-名词模式（例如，`user-auth`、`payment-capture`）
- 连字符小写名称
- 单一焦点（每个功能一个职责）
- 无嵌套（`specs/` 下的扁平结构）

## 何时需要提议的变更

应为以下情况创建提议：
- 新功能或能力
- 对现有行为的破坏性变更
- 架构或模式变更
- 改变行为的性能优化
- 影响访问模式的安全更新

以下情况不需要提议：
- 恢复预期行为的错误修复
- 拼写错误或格式修复
- 非破坏性依赖更新
- 为现有行为添加测试
- 文档澄清

## 为什么采用这种方法

干净的未来状态存储提供：
- **可读性**：无差异语法污染
- **AI 兼容性**：AI 工具理解的标准 markdown
- **简单性**：无需特殊解析或处理
- **工具无关性**：任何差异工具都可显示变更
- **明确意图**：明确的提议记录推理过程