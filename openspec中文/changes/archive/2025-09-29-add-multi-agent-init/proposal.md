# 设置后允许额外 AI 工具初始化

## 摘要
- 让 `openspec init` 为已包含 OpenSpec 结构的项目配置新的 AI 编码工具。
- 通过跳过结构创建并仅为用户明确选择的工具生成文件来保持初始化流程安全。
- 提供清晰反馈，让用户知道哪些工具文件是添加的 versus 已存在的。

## 动机
今天 `openspec init` 一旦 `openspec/` 目录存在就退出并报错。这保护了目录布局，但它阻止了从一个助手（例如，Claude Code）开始并后来想要添加另一个如 Cursor 的团队。他们必须手动创建这些文件或在干净克隆中重新运行 `init`，这破坏了"轻松入门"的承诺。让命令扩展现有安装保持工作流一致并避免手动文件管理。

## 提案
1. 在 `openspec init` 开始时检测现有 OpenSpec 结构并分支到"扩展"模式而不是退出。
   - 宣布基础结构已存在，命令将只管理 AI 工具配置文件。
   - 保持对不得覆盖的目录或文件的现有防护。
2. 即使在扩展模式下也呈现 usual AI 工具选择提示，显示哪些工具已配置。
   - 跳过仍为"即将推出"的禁用选项。
   - 标记已配置的工具，让用户知道选择它们是否会刷新或添加文件。
3. 当用户选择额外工具时，生成与全新运行将创建的相同初始化文件（例如，Cursor 工作区文件），同时保持未触及的工具完整，除了标记管理的部分。
   - 当用户未选择新工具时什么也不做，并保持之前的错误消息以避免静默成功。
4. 在执行工作后退出代码 0 前总结结果（创建、刷新、跳过）。
   - 包含友好指导，说明共享内容的未来更新仍来自 `openspec update`。

## 范围外
- 更改 `openspec update` 发现或更新 AI 工具文件的方式。
- 支持超出已连接到 CLI 的全新 AI 工具。
- 为一次运行中选择多个工具添加非交互标志（如需要跟进）。

## 风险和缓解措施
- **用户对扩展模式的困惑** → 在提示前明确记录将发生什么，之后总结结果。
- **意外覆盖** → 继续使用基于标记的更新，除非用户选择该工具，否则跳过文件。
- **如果初始化中途失败导致状态不一致** → 重用现有的回滚/事务逻辑，使部分写入清理。