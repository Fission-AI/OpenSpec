# OpenSpec 约定规范

## 新增要求

### 要求：采用结构化格式

行为规范应采用带有 `### Requirement:` 和 `#### Scenario:` 标题的结构化格式作为默认格式。

#### 场景：为行为使用结构化标题

- **当** 记录行为要求时
- **则** 使用 `### Requirement:` 作为要求
- **并且** 使用 `#### Scenario:` 作为场景，带有粗体 WHEN/THEN/AND 关键字

## 目的

OpenSpec 约定应定义系统功能如何记录、变更如何提议和跟踪，以及规范如何随时间演变。这个元规范作为 OpenSpec 自身约定的真相来源。

## 核心原则

系统应遵循这些原则：
- 规范反映当前已构建和部署的内容
- 变更包含应变更内容的提案
- AI 驱动文档过程
- 规范是与部署代码保持同步的活文档

## 目录结构

当初始化 OpenSpec 项目时
则它应具有此结构：
```
openspec/
├── project.md              # 项目特定上下文
├── README.md               # AI 助手指令
├── specs/                  # 当前部署的功能
│   └── [capability]/       # 单一、专注的功能
│       ├── spec.md         # WHAT 和 WHY
│       └── design.md       # HOW（可选，用于已建立的模式）
└── changes/                # 提议的变更
   ├── [change-name]/      # 描述性变更标识符
   │   ├── proposal.md     # 为什么、什么和影响
   │   ├── tasks.md        # 实现清单
   │   ├── design.md       # 技术决策（可选）
   │   └── specs/          # 完整未来状态
   │       └── [capability]/
   │           └── spec.md # 纯净 markdown（无差异语法）
   └── archive/            # 已完成的变更
       └── YYYY-MM-DD-[name]/
```

## 规范格式

### 要求：行为规范的结构化格式

行为规范应使用带有统一条标题和关键字的结构化格式，以确保视觉一致性和可解析性。

#### 场景：编写要求部分

- **当** 在行为规范中记录要求时
- **则** 使用格式为 `### Requirement: [Name]` 的三级标题
- **并且** 紧跟描述核心行为的 SHALL 陈述
- **并且** 保持要求名称描述性且不超过 50 个字符

#### 场景：记录场景

- **当** 记录特定行为或用例时
- **则** 使用格式为 `#### Scenario: [Description]` 的四级标题
- **并且** 使用带粗体关键字的项目符号作为步骤：
  - **GIVEN** 用于初始状态（可选）
  - **WHEN** 用于条件或触发器
  - **THEN** 用于预期结果
  - **AND** 用于额外结果或条件

#### 场景：添加实现细节

- **当** 步骤需要额外细节时
- **则** 在主步骤下使用子项目符号
- **并且** 保持一致的缩进
  - 子项目符号提供示例或具体细节
  - 保持子项目符号简洁

### 要求：格式灵活性

结构化格式应作为行为规范的默认格式，但在内容类型更合适时可以使用替代格式。

#### 场景：记录 API 规范

- **当** 记录 REST API 端点或 GraphQL 模式时
- **则** 可以使用 OpenAPI、GraphQL SDL 或类似格式
- **并且** 规范应清楚地指示正在使用的格式
- **并且** 行为方面仍应遵循结构化格式

#### 场景：记录数据模式

- **当** 记录数据结构、数据库模式或配置时
- **则** 可以使用 JSON Schema、SQL DDL 或类似格式
- **并且** 包含行为规则和约束的结构化格式

#### 场景：使用简化格式

- **当** 记录没有复杂场景的简单功能时
- **则** 可以使用没有完整结构的简化 WHEN/THEN 格式
- **并且** 这应在功能内保持一致

## 变更存储约定

### 未来状态存储

当创建变更提案时
则存储受影响规范的完整未来状态
并且使用纯净 markdown 而无差异语法

`changes/[name]/specs/` 目录应包含：
- 变更后的完整规范文件
- 无 `+` 或 `-` 前缀的纯净 markdown
- 最终预期状态的所有格式和结构

### 提案格式

当记录变更内容时
则提案应明确描述每个变更：

```markdown
**[部分或行为名称]**
- 从：[当前状态/要求]
- 到：[未来状态/要求]
- 原因：[为什么需要此变更]
- 影响：[破坏性/非破坏性，谁受影响]
```

这种明确格式弥补了没有内联差异的不足，并确保审阅者确切了解将发生什么变更。

## 变更生命周期

变更过程应遵循这些状态：

1. **提议**：AI 创建带有未来状态规范和明确提案的变更
2. **审阅**：人类审阅提案和未来状态
3. **批准**：变更被批准实施
4. **实施**：遵循 tasks.md 清单（可跨越多个 PR）
5. **部署**：变更部署到生产环境
6. **更新**：`specs/` 中的规范更新以匹配部署的现实
7. **归档**：变更移至 `archive/YYYY-MM-DD-[name]/`

## 查看变更

当审阅提议的变更时
则审阅者可以使用以下方式比较：
- GitHub PR 差异视图当变更被提交时
- 命令行：`diff -u specs/[capability]/spec.md changes/[name]/specs/[capability]/spec.md`
- 任何比较当前与未来状态的视觉差异工具

系统依赖工具生成差异而不是存储它们。

## 功能命名

功能应使用：
- 动词-名词模式（例如，`user-auth`、`payment-capture`）
- 连字符小写名称
- 单一焦点（每个功能一个责任）
- 无嵌套（`specs/` 下的平面结构）

## 何时变更需要提案

应为以下情况创建提案：
- 新功能或能力
- 对现有行为的破坏性变更
- 架构或模式变更
- 改变行为的性能优化
- 影响访问模式的安全更新

不需要提案的情况：
- 恢复预期行为的错误修复
- 拼写错误或格式修复
- 非破坏性依赖更新
- 为现有行为添加测试
- 文档澄清

## 为什么采用这种方法

纯净的未来状态存储提供：
- **可读性**：无差异语法污染
- **AI 兼容性**：AI 工具理解的标准 markdown
- **简单性**：无需特殊解析或处理
- **工具无关性**：任何差异工具都可显示变更
- **明确意图**：明确的提案记录推理

结构化格式添加：
- **视觉一致性**：要求和场景前缀使部分立即可识别
- **可解析性**：一致的结构启用工具和自动化
- **灵活性**：在适当时支持替代格式
- **渐进采用**：现有规范可以逐步迁移