# OpenSpec 约定 - 变更

## 修改后的要求

### 要求：基于标题的要求识别

要求标题应作为当前规范和提议变更之间程序化匹配的唯一标识符。

#### 场景：程序化匹配要求

- **当** 处理增量变更时
- **则** 使用 `### Requirement: [Name]` 标题作为唯一标识符
- **并且** 使用标准化标题进行匹配：`normalize(header) = trim(header)`
- **并且** 标准化后使用区分大小写的相等性比较标题

#### 场景：处理要求重命名

- **当** 重命名要求时
- **则** 使用特殊的 `## RENAMED Requirements` 部分
- **并且** 明确指定旧名称和新名称：
  ```markdown
  ## RENAMED Requirements
  - FROM: `### Requirement: Old Name`
  - TO: `### Requirement: New Name`
  ```
- **并且** 如果内容也发生变更，则在 MODIFIED 下使用新标题包含

#### 场景：验证标题唯一性

- **当** 创建或修改要求时
- **则** 确保规范内无重复标题
- **并且** 验证工具应将重复标题标记为错误

### 要求：变更存储约定

变更提案应仅存储对规范的添加、修改和删除，而不是完整的未来状态。

#### 场景：创建带有添加的变更提案

- **当** 创建添加新要求的变更提案时
- **则** 仅在 `## ADDED Requirements` 下包含新要求
- **并且** 每个要求应包含其完整内容
- **并且** 使用标准结构化格式的要求和场景

#### 场景：创建带有修改的变更提案  

- **当** 创建修改现有要求的变更提案时
- **则** 在 `## MODIFIED Requirements` 下包含修改的要求
- **并且** 使用与当前规范中相同的标题文本（标准化）
- **并且** 包含完整的修改要求（不是差异）
- **并且** 可选择使用内联注释如 `← (was X)` 注释变更内容

#### 场景：创建带有删除的变更提案

- **当** 创建删除要求的变更提案时
- **则** 在 `## REMOVED Requirements` 下列出它们
- **并且** 使用标准化标题文本进行识别
- **并且** 包含删除原因
- **并且** 如适用，记录任何迁移路径

`changes/[name]/specs/` 目录应包含：
- 仅显示变更的增量文件
- ADDED、MODIFIED、REMOVED 和 RENAMED 要求的部分
- 用于要求识别的标准化标题匹配
- 使用结构化格式的完整要求
- 每个要求的变更类型清晰指示

#### 场景：使用标准输出符号

- **当** 在 CLI 输出中显示增量操作时
- **则** 使用这些标准符号：
  - `+` 表示 ADDED（绿色）
  - `~` 表示 MODIFIED（黄色）
  - `-` 表示 REMOVED（红色）
  - `→` 表示 RENAMED（青色）

### 要求：归档过程增强

归档过程应使用基于标题的匹配程序化地将增量变更应用到当前规范。

#### 场景：使用增量归档变更

- **当** 归档已完成的变更时
- **则** 归档命令应：
  1. 首先解析 RENAMED 部分并应用重命名
  2. 解析 REMOVED 部分并通过标准化标题匹配删除
  3. 解析 MODIFIED 部分并通过标准化标题匹配替换（如已重命名则使用新名称）
  4. 解析 ADDED 部分并追加新要求
- **并且** 验证所有 MODIFIED/REMOVED 标题在当前规范中存在
- **并且** 验证 ADDED 标题尚不存在
- **并且** 在主 specs/ 目录中生成更新的规范

#### 场景：处理归档期间的冲突

- **当** 增量变更与当前规范状态冲突时
- **则** 归档命令应报告具体冲突
- **并且** 要求手动解决后继续
- **并且** 提供解决冲突的明确指导