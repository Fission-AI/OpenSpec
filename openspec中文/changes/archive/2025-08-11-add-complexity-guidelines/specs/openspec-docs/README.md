# OpenSpec 指令

本文档为 AI 编码助手提供如何使用 OpenSpec 约定进行规范驱动开发的指令。在 OpenSpec 启用的项目上工作时，请严格按照这些规则执行。

## 核心原则

OpenSpec 是一个 AI 原生的变更驱动开发系统，其中：
- **规范** (`specs/`) 反映当前已构建和部署的内容
- **变更** (`changes/`) 包含应变更内容的提议
- **AI 驱动过程** - 您生成提议，人类审查和批准
- **规范是活文档** - 始终与部署的代码保持同步

## 从简单开始

**默认采用最小实现：**
- 新功能初始应少于 100 行代码
- 使用最简单的有效解决方案
- 避免过早优化（无性能数据不进行缓存、并行化或复杂模式）
- 选择无聊的技术而非前沿解决方案

**复杂性触发器** - 仅在以下情况下添加复杂性：
- **性能数据** 显示当前解决方案太慢
- **规模要求** 有具体数字（>1000 用户，>100MB 数据）
- **多个用例** 需要相同抽象
- **法规合规** 要求特定模式
- **安全威胁** 简单解决方案无法解决

触发时，在变更提议中记录具体理由。

## 目录结构

```
openspec/
├── project.md              # 项目特定上下文（技术栈、约定）
├── README.md               # 本文件 - OpenSpec 指令
├── specs/                  # 当前真相 - 已构建内容
│   ├── [capability]/       # 单一、专注的功能
│   │   ├── spec.md         # 功能做什么和为什么
│   │   └── design.md       # 如何构建（已建立的模式）
│   └── ...
├── changes/                # 提议的变更 - 我们正在变更的内容
│   ├── [change-name]/
│   │   ├── proposal.md     # 为什么、什么、影响（整合）
│   │   ├── tasks.md        # 实现检查清单
│   │   ├── design.md       # 技术决策（可选，用于复杂变更）
│   │   └── specs/          # 受影响规范的未来状态
│   │       └── [capability]/
│   │           └── spec.md # 干净的 markdown（无差异语法）
│   └── archive/            # 已完成的变更（带日期）
```

### 功能组织

**使用功能而非特性** - `specs/` 下的每个目录代表单一、专注的职责：
- **动词-名词命名**：`user-auth`、`payment-capture`、`order-checkout`
- **10 分钟规则**：每个功能应在 <10 分钟内可理解
- **单一目的**：如果需要"和"来描述，则拆分

示例：
```
✅ 好：user-auth, user-sessions, payment-capture, payment-refunds
❌ 坏：users, payments, core, misc
```

## 关键行为规则

### 1. 始终从阅读开始

任何任务前：
1. **阅读 `specs/[capability]/spec.md` 中的相关规范** 以了解当前状态
2. **检查 `changes/` 目录中的待定变更** 以查找潜在冲突
3. **阅读 project.md** 了解项目特定约定

### 2. 何时创建变更提议

**始终为以下情况创建变更提议：**
- 新功能或功能
- 破坏性变更（API 变更、模式更新）
- 架构变更或新模式
- 改变行为的性能优化
- 影响认证/访问模式的安全更新
- 需要多个步骤或影响多个系统的任何变更

**跳过提议用于：**
- 恢复预期行为的错误修复
- 拼写错误、格式或注释更新
- 依赖更新（除非破坏性）
- 配置或环境变量变更
- 为现有行为添加测试
- 文档修复

**复杂性评估：**
- 如果您的解决方案需要 >100 行新代码，请证明复杂性的合理性
- 如果添加依赖、框架或架构模式，请记录为什么更简单的替代方案不起作用
- 默认采用单文件实现，直到证明不足

### 3. 创建变更提议

当用户请求重大变更时：

```bash
# 1. 创建变更目录
openspec/changes/[描述性名称]/

# 2. 生成包含所有上下文的 proposal.md
## 为什么
[1-2 句关于问题/机会的描述]

## 什么变更  
[变更列表，包括破坏性变更]

## 影响
- 受影响的规范：[将变更的功能列表]
- 受影响的代码：[关键文件/系统列表]

# 3. 为所有受影响的功能创建未来状态规范
# - 存储变更后的完整规范文件
# - 使用干净的 markdown 无差异语法 (+/- 前缀)
# - 包含最终预期状态的所有格式和结构
specs/
└── [capability]/
    └── spec.md

# 4. 创建包含实现步骤的 tasks.md
## 1. [任务组]
- [ ] 1.1 [具体任务]
- [ ] 1.2 [具体任务]

# 5. 对于复杂变更，添加 design.md
[技术决策和权衡]
```

### 4. 变更生命周期

1. **提议** → 创建包含所有文档的变更目录
2. **审查** → 用户审查和批准提议
3. **实施** → 遵循批准的 tasks.md（可以是多个 PR）
4. **部署** → 用户确认部署
5. **更新规范** → 同步 specs/ 与新现实（如果变更影响系统功能）
6. **归档** → 移动到 `changes/archive/YYYY-MM-DD-[name]/`

### 5. 实施变更

实施已批准的变更时：
1. 严格按照 tasks.md 检查清单执行
2. **完成任务时在 tasks.md 中标记**（例如，`- [x] 1.1 任务完成`）
3. 确保代码与提议的行为匹配
4. 更新任何受影响的测试
5. **将变更保留在 `changes/` 目录中** - 不要在实施 PR 中归档

**多个实施 PR：**
- 变更可以跨多个 PR 实施
- 每个 PR 应更新 tasks.md 以标记已完成的内容
- 不同的开发人员可以处理不同的任务组
- 示例：PR #1 完成任务 1.1-1.3，PR #2 完成任务 2.1-2.4

### 6. 部署后更新规范和归档

**部署后创建单独的 PR**：
1. 将变更移动到 `changes/archive/YYYY-MM-DD-[name]/`
2. 更新 `specs/` 中的相关文件以反映新现实（如果需要）
3. 如果存在 design.md，将已验证的模式合并到 `specs/[capability]/design.md`

这确保变更只有在真正完成和部署后才归档。

### 7. 不需要规范的变更类型

一些变更只影响开发基础设施，不需要规范：
- 初始项目设置（package.json, tsconfig.json 等）
- 开发工具变更（linter, formatter, 构建工具）
- CI/CD 配置
- 开发依赖

对于这些变更：
1. 实施 → 部署 → 标记任务完成 → 归档
2. 完全跳过"更新规范"步骤

### 什么值得规范？

自问：
- 这是用户或其他系统交互的系统功能吗？
- 它有需要文档记录的持续行为吗？
- 新开发人员需要了解它才能使用系统吗？

如果全部否 → 不需要规范（可能只是工具/基础设施）

## 理解规范与代码

### 规范记录 WHAT 和 WHY
```markdown
# 认证规范

用户应使用电子邮件和密码进行认证。

当凭据有效时则颁发 JWT 令牌。
当凭据无效时则返回通用错误。

为什么：防止用户枚举攻击。
```

### 代码记录 HOW
```javascript
// 实现细节
const user = await db.users.findOne({ email });
const valid = await bcrypt.compare(password, user.hashedPassword);
```

**关键区别**：规范捕获从代码中不明显的意图、约束和决策。

## 常见场景

### 新功能请求
```
用户："添加密码重置功能"

您应该：
1. 阅读 specs/user-auth/spec.md
2. 检查 changes/ 中的待定认证变更
3. 创建 changes/add-password-reset/ 并提议
4. 等待批准后再实施
```

### 错误修复
```
用户："当 bio 为空时出现空指针错误"

您应该：
1. 检查规范是否说明 bio 是可选的
2. 如果是 → 直接修复（这是错误）
3. 如果否 → 创建变更提议（这是行为变更）
```

### 基础设施设置
```
用户："初始化 TypeScript 项目"

您应该：
1. 为 TypeScript 设置创建变更提议
2. 实施配置文件（PR #1）
3. 在 tasks.md 中标记任务完成
4. 部署后，创建单独的 PR 进行归档
   （不需要规范更新 - 这是工具，不是功能）
```

## 摘要工作流

1. **接收请求** → 确定是否需要变更提议
2. **阅读当前状态** → 检查规范和待定变更
3. **创建提议** → 生成完整的变更文档
4. **获得批准** → 用户审查提议
5. **实施** → 遵循批准的任务，在 tasks.md 中标记完成的项目
6. **部署** → 用户部署实施
7. **归档 PR** → 创建单独的 PR：
   - 将变更移动到归档
   - 更新规范（如果需要）
   - 标记变更完成

## PR 工作流示例

### 单一开发人员，简单变更
```
PR #1: 实施
- 实施所有任务
- 更新 tasks.md 标记项目完成
- 合并和部署

PR #2: 归档（部署后）
- 移动 changes/feature-x/ → changes/archive/2025-01-15-feature-x/
- 更新规范（如果需要）
```

### 多个开发人员，复杂变更
```
PR #1: Alice 实施认证组件
- 完成任务 1.1, 1.2, 1.3
- 更新 tasks.md 标记这些完成

PR #2: Bob 实施 UI 组件  
- 完成任务 2.1, 2.2
- 更新 tasks.md 标记这些完成

PR #3: Alice 修复集成问题
- 完成剩余任务 1.4
- 更新 tasks.md

[部署所有变更]

PR #4: 归档
- 移动到带部署日期的归档
- 更新规范以反映新认证流程
```

### 关键规则
- **永远不要在实施 PR 中归档** - 变更在部署前未完成
- **始终更新 tasks.md** - 显示准确进度
- **每个变更一个归档 PR** - 明确完成边界
- **归档 PR 包含规范更新** - 保持规范最新

## 功能组织最佳实践

### 命名功能
- 使用 **动词-名词** 模式：`user-auth`、`payment-capture`、`order-checkout`
- 具体化：`payment-capture` 而非 `payments`
- 保持扁平：避免在功能内嵌套功能
- 单一焦点：如果需要"和"来描述，则拆分

### 何时拆分功能
在以下情况下拆分：
- 多个不相关的 API 端点
- 不同的用户角色或参与者
- 独立的部署考虑
- 独立的演进路径

#### 功能边界指南
- 您会单独导入它们吗？→ 单独的功能
- 不同的部署节奏？→ 单独的功能
- 不同的团队拥有它们？→ 单独的功能
- 共享数据模型可以，共享业务逻辑意味着合并

示例：
- user-auth（登录/注销）vs user-sessions（令牌管理）→ 分离
- payment-capture vs payment-refunds → 分离（不同工作流）
- user-profile vs user-settings → 合并（相同数据模型，相同所有者）

### 横切关注点
对于系统范围的策略（速率限制、错误处理、安全），在以下位置记录：
- `project.md` 用于项目范围的约定
- 在相关功能规范中应用它们的地方
- 或为足够复杂的创建专用功能（例如，`api-rate-limiting/`）

### 组织良好的功能示例
```
specs/
├── user-auth/              # 登录、注销、密码重置
├── user-sessions/          # 令牌管理、刷新
├── user-profile/           # 配置文件 CRUD 操作
├── payment-capture/        # 处理付款
├── payment-refunds/        # 处理退款
└── order-checkout/         # 结账工作流
```

有关详细指导，请参见[功能组织指南](../docs/capability-organization.md)。

## 常见场景和澄清

### 决策模糊性：错误 vs 行为变更

当规范缺失或模糊时：
- 如果无规范存在 → 将当前代码行为视为隐式规范，需要提议
- 如果规范模糊 → 需要提议来澄清规范并修复
- 如果代码和规范不一致 → 规范是真理，代码有错误（无需提议修复）
- 如果不确定 → 默认创建提议（更安全的选择）

示例：
```
用户："API 对缺失用户返回 404 但应返回 400"
AI：这是错误（规范说 400）还是行为变更（规范说 404）？
```

### 当您不知道范围时
可以先探索！告诉用户您需要调查，然后创建知情的提议。

### 探索阶段（需要时）

创建提议前，您可能需要探索：
- 用户请求模糊或高层级
- 存在多种实现方法
- 不查看代码就无法确定范围

探索清单：
1. 告诉用户您需要先探索
2. 使用 Grep/Read 了解当前状态
3. 基于发现创建初始提议
4. 通过用户反馈完善

示例：
```
用户："添加缓存以提高性能"
AI："让我探索代码库以了解当前架构并识别缓存机会。"
[探索后]
AI："基于我的分析，我识别了三个可以缓存的区域。这是我的提议..."
```

### 当无规范存在时
将当前代码视为隐式规范。您的提议应记录当前状态和提议的变更。

### 当有疑问时
默认创建提议。跳过不必要的提议比修复未记录的变更更容易。

### AI 工作流适应

使用 OpenSpec 进行任务跟踪：
- 将探索任务与实施任务分开跟踪
- 在进行过程中记录提议创建步骤
- 在提议批准前将实施任务分开

鼓励并行操作：
- 同时阅读多个规范
- 一次检查多个待定变更
- 为效率批量相关搜索

进度沟通：
- "正在探索代码库以了解范围..."
- "正在基于发现创建提议..."
- "正在实施已批准的变更..."

### 对于 AI 助手
- **偏向简单性** - 提议最小的有效解决方案
- 在提议前自由使用探索工具
- 为效率批量操作
- 沟通您的进度
- 基于发现修订提议是可以的
- **质疑复杂性** - 如果您的解决方案感觉复杂，先简化

## 边缘情况处理

### 多功能变更
创建一个提议：
- 列出所有受影响的功能
- 显示每个功能的变更
- 有统一的任务列表
- 整体获得批准

### 过时的规范
如果规范明显过时：
1. 创建提议将规范更新为匹配现实
2. 在单独的提议中实施新功能
3. 或在具有明确部分的一个提议中组合两者

### 紧急热修复
对于关键生产问题：
1. 宣布："这是一个紧急修复"
2. 立即实施修复
3. 创建追溯提议
4. 部署后更新规范
5. 在归档中用 [EMERGENCY] 标记

### 纯重构
无需提议用于：
- 代码格式/样式
- 内部重构（相同 API）
- 性能优化（相同行为）
- 为无类型代码添加类型

需要提议用于：
- API 变更（即使兼容）
- 数据库模式变更
- 架构变更
- 新依赖

### 可观察性添加
无需提议用于：
- 添加日志语句
- 新指标/跟踪
- 调试添加
- 错误跟踪

需要提议如果：
- 变更日志格式/结构
- 添加新监控服务
- 变更记录内容（隐私）

## 记住

- 您是过程驱动者 - 自动化文档负担
- 规范必须始终反映部署的现实
- 变更是提议的，不是强加的
- 影响分析防止意外
- **简单性是力量** - 只是 markdown 文件，最小解决方案
- 从简单开始，仅在有理由时添加复杂性

通过遵循这些约定，您实现了真正的规范驱动开发，其中文档保持最新，变更可追溯，演进是有意的。