# OpenSpec 并行差异修复计划

## 问题摘要
- 活跃变更在归档时应用要求级别的替换。当两个变更触及同一要求时，第二次归档会覆盖第一次并静默丢弃场景（例如，Windsurf vs. Kilo Code 斜杠命令更新）。
- 归档工作流（`src/core/archive.ts:191` 和 `src/core/archive.ts:501`）通过用变更差异中包含的内容替换整个要求块来重建主要规范。差异格式（`src/core/parsers/requirement-blocks.ts:113`）没有基础版本或场景级别操作的概念。
- 工具无法检测变更作者的起点与实时规范之间的分歧，因此并行开发会在没有警告的情况下破坏事实来源。

## 观察到的故障模式
- 变更 A（`add-windsurf-workflows`）在 `斜杠命令配置` 下添加了一个 Windsurf 场景。
- 变更 B（`add-kilocode-workflows`）向同一要求添加了一个 Kilo Code 场景，从 pre-Windsurf 规范开始。
- 变更 A 归档后，主要规范包含两个场景。
- 当变更 B 归档时，`buildUpdatedSpec` 看到 `斜杠命令配置` 的 `修改` 块，并用该变更中提供的四场景变体替换要求。因为该文件从未了解 Windsurf，所以 Windsurf 场景消失了。
- 没有警告、差异或冲突指示器——归档成功完成，事实来源规范现在省略了一个已发布的场景。

## 根本原因
1. **仅替换语义。** `buildUpdatedSpec` 执行要求块的哈希映射替换，无法合并或比较单个场景（`src/core/archive.ts:455`-`src/core/archive.ts:526`）。
2. **缺少基础指纹。** 变更不持久化它们编写时所基于的要求内容，因此归档步骤无法判断实时规范是否分歧。
3. **单级粒度。** 差异语言只理解要求。即使我们引入了场景级别解析，没有伴随的合并策略，我们仍然会丢失同级编辑。
4. **缺少冲突用户体验。** CLI 从不强制贡献者协调并行更新。没有 `git merge`、`git rebase` 或冲突标记的等效物。

## 设计目标
- 无论归档顺序如何，保留每个批准的场景。
- 当实时规范与作者的基础分歧时，检测并阻止推测性归档。
- 提供确定性的、可审查的冲突解决流程，反映源代码控制最佳实践。
- 保持编写体验符合人体工程学：差异应保持为人类可编辑的 markdown。
- 支持增量采用，以便现有存储库可以向前推进而不会破坏活跃工作。

## 提议的修复：分层修复

### 阶段 0 – 止血（检测和防护栏）
1. **在每个变更旁边持久化要求指纹。**
   - 在搭建或验证变更时，为每个 `修改`/`删除`/`重命名` 条目捕获当前要求主体，并将其写入 `changes/<id>/meta.json`。
   - 存储基础要求内容的稳定哈希（例如，SHA-256）和原始文本本身，以便以后合并。
2. **在归档期间验证指纹。**
   - 在 `buildUpdatedSpec` 修改规范之前，从实时规范重新计算要求哈希。
   - 如果哈希与存储的基础不同，中止并指示用户重新基准化。这使得破坏性路径不可能。
3. **在 CLI 输出中显示意图。**
   - 显示哪些要求已过时，它们何时分歧，以及哪个变更最后触及它们。
4. **记录临时手动缓解措施。**
   - 更新 `openspec/AGENTS.md` 和文档，以便贡献者知道每当另一个变更落地时重新运行 `openspec change sync`（参见阶段 1）。

_结果：_ 在我们研究更丰富的合并故事时，我们立即防止数据丢失。

### 阶段 1 – 添加重新基准化工作流（作者端合并）
1. **引入 `openspec change sync <id>`（或 `rebase`）。**
   - 读取存储的基础快照、当前规范和作者的差异。
   - 对每个要求执行 3 路合并。最初在 markdown 行上进行简单的 diff3 是可以接受的，因为我们已经操作要求大小的块。
   - 如果合并干净，用合并的文本重写 `修改` 块并刷新存储的指纹。
   - 在冲突时，在变更差异内写入冲突标记（类似于 Git），并要求作者在重新运行验证之前手动编辑。
2. **丰富验证器消息。**
   - `openspec validate` 应标记未解决的冲突标记或指纹不匹配，以便错误在工作流早期出现。
3. **改进差异工具。**
   - 扩展 `openspec diff` 以比较变更差异与实时规范，并突出显示待处理的合并。
4. **可选：** 提供 `--rewrite-scenarios` 助手，合并场景的项目符号列表以减少手动编辑噪音。

_结果：_ 贡献者可以在归档之前安全地将其工作与最新规范协调，恢复真正的并行开发。

### 阶段 2 – 增加差异粒度
1. **使用场景级别指令扩展差异语言。**
   - 允许 `## 修改的要求` + `## 新增场景` / `## 修改的场景` 部分嵌套在要求标题下。
   - 由存储在 `meta.json` 中的稳定场景标识符（显式 ID 或生成的哈希）支持。这让系统能够推理单个场景。
2. **教解析器理解嵌套操作。**
   - 更新 `parseDeltaSpec` 以发出场景级别操作以及要求块。
   - 更新 `buildUpdatedSpec`（或其替换）以合并场景列表，在确定性方式插入新条目时保留顺序。
3. **自动化迁移。**
   - 提供一次性命令，检查每个现有规范，注入场景 ID，并将进行中的变更差异重写为更丰富的格式。
4. **当两个变更编辑同一场景主体或描述时，继续依赖阶段 1 的重新基准化流程进行冲突。**

_结果：_ 大多数并发更新变得可交换，大大减少了人工合并的几率。

### 阶段 3 – 结构化规范图（长期）
1. **定义稳定的要求 ID。**
   - 在规范中嵌入 `要求 ID：<uuid>` 标记，以便重命名和移动可跟踪。
   - 这启用了未来功能，如跨能力引用和更好的差异可视化。
2. **将规范编辑建模为 AST 上的操作。**
   - 为要求/场景/元数据构建中间表示（IR）。
   - 使用操作转换或类似 CRDT 的技术来保证合并关联性。
3. **直接与 Git 集成。**
   - 提供可选的 `openspec branch` 搭建，将规范变更与 Git 分支对齐，让团队利用 Git 的冲突编辑器来处理 markdown IR。

_结果：_ OpenSpec 从基于替换的更新毕业为弹性的、意图保留的规范管理平台。

## 迁移和产品影响
- **回填元数据：** 在初始推出期间为所有活跃变更和当前主要规范添加哈希。
- **CLI 用户体验：** 新命令（`change sync`、增强的 `archive`）需要文档、帮助文本和发布说明。
- **文档和 AGENTS 更新：** 加强重新基准化工作流并向 AI 助手解释冲突解决。
- **测试：** 引入覆盖分歧要求指纹和合并解决逻辑的固定装置。
- **遥测（可选）：** 记录指纹不匹配，以便我们可以看到团队在推出后多久遇到冲突。

## 开放问题 / 风险
- 当多个变更在不同点插入时，我们应该如何排序场景？（考虑可选的 `position` 元数据或确定性字母顺序回退。）
- 如果贡献者删除 `meta.json` 文件，优雅的故障模式应该是什么？（CLI 应应需重新创建指纹。）
- 我们需要支持无法在归档前轻松重新运行同步命令的离线作者吗？（潜在的 `--accept-outdated` 紧急逃生舱口。）
- 将如何处理归档的历史变更？我们可能需要迁移脚本以追溯嵌入指纹，以便重新验证成功。

## 立即下一步
1. 在 `openspec change validate` 期间原型化指纹捕获，并在不匹配时阻止归档。
2. 使用基于行的 diff3 合并和冲突标记发布 `openspec change sync`。
3. 更新贡献者文档和 AI 指令，要求在归档前运行 `sync`。
4. 将场景级别差异扩展和迁移路径规划为后续 RFC。